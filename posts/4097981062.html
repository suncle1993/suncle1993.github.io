<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png"><link rel="icon" href="/img/android-chrome-192x192.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="Suncle Chen"><meta name="keywords" content=""><meta name="description" content="多线程基础概念并行与并发  并行：同时处理多个任务，必须在多核环境下 一段时间内同时处理多个任务，单核也可以并发  并发手段  线程：内核空间的调度 进程：内核空间的调度 协程：用户空间的调度  线程可以允许程序在同一进程空间中并发运行多个操作。本次主要介绍Python标准库中的多线程模块threading。"><meta property="og:type" content="article"><meta property="og:title" content="Python多线程"><meta property="og:url" content="https://suncle.me/posts/4097981062.html"><meta property="og:site_name" content="Suncle"><meta property="og:description" content="多线程基础概念并行与并发  并行：同时处理多个任务，必须在多核环境下 一段时间内同时处理多个任务，单核也可以并发  并发手段  线程：内核空间的调度 进程：内核空间的调度 协程：用户空间的调度  线程可以允许程序在同一进程空间中并发运行多个操作。本次主要介绍Python标准库中的多线程模块threading。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2017-03-22T17:57:30.000Z"><meta property="article:modified_time" content="2022-08-25T17:31:47.976Z"><meta property="article:author" content="Suncle Chen"><meta property="article:tag" content="Python"><meta property="article:tag" content="多线程"><meta property="article:tag" content="threading"><meta name="twitter:card" content="summary_large_image"><meta name="referrer" content="no-referrer-when-downgrade"><title>Python多线程 - Suncle</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"suncle.me",root:"/",version:"1.9.2",typing:{enable:!1,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:"41fc030db57d5570dd22f78997dc4a7e",google:"UA-72506112-1",gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Suncle" type="application/atom+xml">
</head><body><header><div class="header-inner" style="height:60vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Suncle&#39;s Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/categories/newsletter/"><i class="iconfont icon-mail"></i> 周刊</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-books"></i> 更多</a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类 </a><a class="dropdown-item" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签 </a><a class="dropdown-item" href="/atom.xml"><i class="iconfont icon-rss-fill"></i> RSS</a></div></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/suncle-banner.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle">Python多线程</span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2017-03-23 01:57" pubdate>2017年3月23日 凌晨</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 24k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 200 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar category-bar" style="margin-right:-1rem"><div class="category-list"><div class="category row nomargin-x"><a class="category-item list-group-item category-item-action col-10 col-md-11 col-xm-11" title="python" id="heading-23eeeb4347bdd26bfc6b7ee9a3b755dd" role="tab" data-toggle="collapse" href="#collapse-23eeeb4347bdd26bfc6b7ee9a3b755dd" aria-expanded="true">python <span class="list-group-count">(32)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-23eeeb4347bdd26bfc6b7ee9a3b755dd" role="tabpanel" aria-labelledby="heading-23eeeb4347bdd26bfc6b7ee9a3b755dd"><div class="category-post-list"><a href="/posts/2114861712.html" title="Python Google Protocol Buffer" class="list-group-item list-group-item-action"><span class="category-post">Python Google Protocol Buffer</span> </a><a href="/posts/3838453869.html" title="Python IO" class="list-group-item list-group-item-action"><span class="category-post">Python IO</span> </a><a href="/posts/501648532.html" title="Python-WSGI接口" class="list-group-item list-group-item-action"><span class="category-post">Python-WSGI接口</span> </a><a href="/posts/1140005001.html" title="Python-pymysql" class="list-group-item list-group-item-action"><span class="category-post">Python-pymysql</span> </a><a href="/posts/3371524817.html" title="Python函数" class="list-group-item list-group-item-action"><span class="category-post">Python函数</span> </a><a href="/posts/3373145519.html" title="Python函数定义及参数详解" class="list-group-item list-group-item-action"><span class="category-post">Python函数定义及参数详解</span> </a><a href="/posts/3953642204.html" title="Python单元测试" class="list-group-item list-group-item-action"><span class="category-post">Python单元测试</span> </a><a href="/posts/2639636733.html" title="Python基本数据类型-list-tuple-dict-set" class="list-group-item list-group-item-action"><span class="category-post">Python基本数据类型-list-tuple-dict-set</span> </a><a href="/posts/4097981062.html" title="Python多线程" class="list-group-item list-group-item-action active"><span class="category-post">Python多线程</span> </a><a href="/posts/1609178714.html" title="Python字符串" class="list-group-item list-group-item-action"><span class="category-post">Python字符串</span> </a><a href="/posts/3043416172.html" title="Python实现通用web框架" class="list-group-item list-group-item-action"><span class="category-post">Python实现通用web框架</span> </a><a href="/posts/2568280681.html" title="Python常用模块集锦" class="list-group-item list-group-item-action"><span class="category-post">Python常用模块集锦</span> </a><a href="/posts/668369792.html" title="Python异常处理" class="list-group-item list-group-item-action"><span class="category-post">Python异常处理</span> </a><a href="/posts/3005931287.html" title="Python拉链法和开地址法实现字典" class="list-group-item list-group-item-action"><span class="category-post">Python拉链法和开地址法实现字典</span> </a><a href="/posts/1516127351.html" title="Python描述器" class="list-group-item list-group-item-action"><span class="category-post">Python描述器</span> </a><a href="/posts/2253555633.html" title="Python时间模块常用操作总结" class="list-group-item list-group-item-action"><span class="category-post">Python时间模块常用操作总结</span> </a><a href="/posts/858751997.html" title="Python答疑解惑" class="list-group-item list-group-item-action"><span class="category-post">Python答疑解惑</span> </a><a href="/posts/3541559492.html" title="Python网络编程" class="list-group-item list-group-item-action"><span class="category-post">Python网络编程</span> </a><a href="/posts/2033838900.html" title="Python装饰器" class="list-group-item list-group-item-action"><span class="category-post">Python装饰器</span> </a><a href="/posts/106366875.html" title="Python装饰器实现函数动态类型检查" class="list-group-item list-group-item-action"><span class="category-post">Python装饰器实现函数动态类型检查</span> </a><a href="/posts/2276895921.html" title="Python解构与封装" class="list-group-item list-group-item-action"><span class="category-post">Python解构与封装</span> </a><a href="/posts/2607945880.html" title="Python解析式" class="list-group-item list-group-item-action"><span class="category-post">Python解析式</span> </a><a href="/posts/3226889536.html" title="Python面向对象基础" class="list-group-item list-group-item-action"><span class="category-post">Python面向对象基础</span> </a><a href="/posts/2725239063.html" title="Python面向对象的魔术方法" class="list-group-item list-group-item-action"><span class="category-post">Python面向对象的魔术方法</span> </a><a href="/posts/1924480698.html" title="SQLAlchemy使用" class="list-group-item list-group-item-action"><span class="category-post">SQLAlchemy使用</span> </a><a href="/posts/599780751.html" title="【填坑系列】Python习题集" class="list-group-item list-group-item-action"><span class="category-post">【填坑系列】Python习题集</span> </a><a href="/posts/2323272316.html" title="【填坑系列】Python基础知识总目录" class="list-group-item list-group-item-action"><span class="category-post">【填坑系列】Python基础知识总目录</span> </a><a href="/posts/139111991.html" title="从Python调用堆栈获取行号等信息" class="list-group-item list-group-item-action"><span class="category-post">从Python调用堆栈获取行号等信息</span> </a><a href="/posts/10731460.html" title="使用Google翻译Api" class="list-group-item list-group-item-action"><span class="category-post">使用Google翻译Api</span> </a><a href="/posts/4100952181.html" title="微博爬取热搜榜和热门话题" class="list-group-item list-group-item-action"><span class="category-post">微博爬取热搜榜和热门话题</span> </a><a href="/posts/3984252732.html" title="设计一个基于flask的高并发高可用的查询ip的http服务" class="list-group-item list-group-item-action"><span class="category-post">设计一个基于flask的高并发高可用的查询ip的http服务</span> </a><a href="/posts/1143805574.html" title="详解supervisor进程管理" class="list-group-item list-group-item-action"><span class="category-post">详解supervisor进程管理</span></a></div></div></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">Python多线程</h1><div class="markdown-body"><h1 id="多线程基础概念"><a href="#多线程基础概念" class="headerlink" title="多线程基础概念"></a>多线程基础概念</h1><p><strong>并行与并发</strong></p><ul><li>并行：同时处理多个任务，必须在多核环境下</li><li>一段时间内同时处理多个任务，单核也可以并发</li></ul><p><strong>并发手段</strong></p><ul><li>线程：内核空间的调度</li><li>进程：内核空间的调度</li><li>协程：用户空间的调度</li></ul><p>线程可以允许程序在同一进程空间中并发运行多个操作。本次主要介绍Python标准库中的多线程模块threading。</p><span id="more"></span><h1 id="threading模块"><a href="#threading模块" class="headerlink" title="threading模块"></a>threading模块</h1><h2 id="线程初始化"><a href="#线程初始化" class="headerlink" title="线程初始化"></a>线程初始化</h2><p>使用threading模块的Thread类初始化对象然后调用start方法启动线程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>(<span class="hljs-params">num</span>):<br>    time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;worker-&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(num))<br><br><span class="hljs-comment"># 创建线程对象 target参数是一个函数， 这个函数即线程要执行的逻辑</span><br>threads = [threading.Thread(target=worker, args=(i, ))<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)]<br><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads:<br>    t.start()<br>    <span class="hljs-comment"># start 方法启动一个线程， 当这个线程的逻辑执行完毕的时候，线程自动退出, Python 没有提供主动退出线程的方法</span><br><br><span class="hljs-comment"># 输出以下结果</span><br>worker-0worker-1worker-2worker-<span class="hljs-number">3</span><br><br><br><br>worker-<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>初始化的五个线程的执行逻辑中的print方法打印字符串及换行符出现了随机分布，即出现了资源竞争。</p><h2 id="给线程传递参数"><a href="#给线程传递参数" class="headerlink" title="给线程传递参数"></a>给线程传递参数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>(<span class="hljs-params">*args, **kwargs</span>):<br>    time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(args)<br>    <span class="hljs-built_in">print</span>(kwargs)<br><br>threads = threading.Thread(target=worker, args=(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), kwargs=&#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-string">&#x27;b&#x27;</span>&#125;).start()<br><br><span class="hljs-comment"># 输出</span><br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>&#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-string">&#x27;b&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>args传递位置参数，kwargs传递关键字参数。</p><h2 id="Thread常用参数和方法"><a href="#Thread常用参数和方法" class="headerlink" title="Thread常用参数和方法"></a>Thread常用参数和方法</h2><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">help</span>(threading.Thread)</span><br></code></pre></td></tr></table></figure><p>可以看到Thread函数的初始化方法中的参数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">|  __init__(self, group=<span class="hljs-literal">None</span>, target=<span class="hljs-literal">None</span>, name=<span class="hljs-literal">None</span>, args=(), kwargs=<span class="hljs-literal">None</span>, *, daemon=<span class="hljs-literal">None</span>)<br>|      This constructor should always be called <span class="hljs-keyword">with</span> keyword arguments. Arguments are:<br>|      <br>|      *group* should be <span class="hljs-literal">None</span>; reserved <span class="hljs-keyword">for</span> future extension when a ThreadGroup<br>|      <span class="hljs-keyword">class</span> <span class="hljs-title class_">is</span> implemented.<br>|      <br>|      *target* <span class="hljs-keyword">is</span> the <span class="hljs-built_in">callable</span> <span class="hljs-built_in">object</span> to be invoked by the run()<br>|      method. Defaults to <span class="hljs-literal">None</span>, meaning nothing <span class="hljs-keyword">is</span> called.<br>|      <br>|      *name* <span class="hljs-keyword">is</span> the thread name. By default, a unique name <span class="hljs-keyword">is</span> constructed of<br>|      the form <span class="hljs-string">&quot;Thread-N&quot;</span> where N <span class="hljs-keyword">is</span> a small decimal number.<br>|      <br>|      *args* <span class="hljs-keyword">is</span> the argument <span class="hljs-built_in">tuple</span> <span class="hljs-keyword">for</span> the target invocation. Defaults to ().<br>|      <br>|      *kwargs* <span class="hljs-keyword">is</span> a dictionary of keyword arguments <span class="hljs-keyword">for</span> the target<br>|      invocation. Defaults to &#123;&#125;.<br></code></pre></td></tr></table></figure><h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><p>表示线程名称，默认情况下，线程名称是<code>Thread-N</code>，N是一个较小的十进制数。我们可以传递name参数，控制线程名称。</p><p>以下会导入logging模块来显示线程的名称等详细信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> logging<br><br>logging.basicConfig(level=logging.DEBUG, <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s %(levelname)s [%(threadName)s] %(message)s&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>(<span class="hljs-params">num</span>):<br>    time.sleep(<span class="hljs-number">1</span>)<br>    logging.info(<span class="hljs-string">&#x27;worker-&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(num))<br><br>threads = [threading.Thread(target=worker, args=(i, ), name=<span class="hljs-string">&#x27;workerthread-&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i)) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)]<br><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads:<br>    t.start()<br><br><span class="hljs-comment"># 输出</span><br><span class="hljs-number">2017</span>-03-<span class="hljs-number">20</span> <span class="hljs-number">21</span>:<span class="hljs-number">39</span>:<span class="hljs-number">29</span>,<span class="hljs-number">339</span> INFO [workerthread-<span class="hljs-number">0</span>] worker-<span class="hljs-number">0</span><br><span class="hljs-number">2017</span>-03-<span class="hljs-number">20</span> <span class="hljs-number">21</span>:<span class="hljs-number">39</span>:<span class="hljs-number">29</span>,<span class="hljs-number">340</span> INFO [workerthread-<span class="hljs-number">1</span>] worker-<span class="hljs-number">1</span><br><span class="hljs-number">2017</span>-03-<span class="hljs-number">20</span> <span class="hljs-number">21</span>:<span class="hljs-number">39</span>:<span class="hljs-number">29</span>,<span class="hljs-number">340</span> INFO [workerthread-<span class="hljs-number">2</span>] worker-<span class="hljs-number">2</span><br><span class="hljs-number">2017</span>-03-<span class="hljs-number">20</span> <span class="hljs-number">21</span>:<span class="hljs-number">39</span>:<span class="hljs-number">29</span>,<span class="hljs-number">340</span> INFO [workerthread-<span class="hljs-number">3</span>] worker-<span class="hljs-number">3</span><br><span class="hljs-number">2017</span>-03-<span class="hljs-number">20</span> <span class="hljs-number">21</span>:<span class="hljs-number">39</span>:<span class="hljs-number">29</span>,<span class="hljs-number">346</span> INFO [workerthread-<span class="hljs-number">4</span>] worker-<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>其中logging模块的basicConfig函数的format中的%(threadName)s就是用来输出当前线程的名称的。</p><blockquote><p>线程可以重名, 线程名并不是线程的唯一标识，但是通常应该避免线程重名，通常的处理手段是加前缀</p></blockquote><h3 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a>daemon</h3><p><strong>Daemon：守护</strong></p><p>和Daemon线程相对应的还有Non-Daemon线程，在此Thread初始化函数中的daemon参数即表示线程是否是Daemon线程。</p><ul><li>Daemon线程：会伴随主线程结束而结束（可以理解为主线程结束，守护线程结束）</li><li>Non-Daemon线程：不会随着主线程结束而结束，主线程需要等待Non-Daemon结束</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> threading<br><br>logging.basicConfig(level=logging.DEBUG, <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s %(levelname)s [%(threadName)s] %(message)s&#x27;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>():<br>    logging.info(<span class="hljs-string">&#x27;starting&#x27;</span>)<br>    time.sleep(<span class="hljs-number">2</span>)<br>    logging.info(<span class="hljs-string">&#x27;stopping&#x27;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    logging.info(<span class="hljs-string">&#x27;starting&#x27;</span>)<br>    t1 = threading.Thread(target=worker, name=<span class="hljs-string">&#x27;worker1&#x27;</span>, daemon=<span class="hljs-literal">False</span>)<br>    t1.start()<br>    time.sleep(<span class="hljs-number">1</span>)<br>    t2 = threading.Thread(target=worker, name=<span class="hljs-string">&#x27;worker2&#x27;</span>, daemon=<span class="hljs-literal">True</span>)<br>    t2.start()<br>    logging.info(<span class="hljs-string">&#x27;stopping&#x27;</span>)<br><br><span class="hljs-comment"># 输出</span><br><span class="hljs-number">2017</span>-03-<span class="hljs-number">20</span> <span class="hljs-number">23</span>:<span class="hljs-number">28</span>:06,<span class="hljs-number">404</span> INFO [MainThread] starting<br><span class="hljs-number">2017</span>-03-<span class="hljs-number">20</span> <span class="hljs-number">23</span>:<span class="hljs-number">28</span>:06,<span class="hljs-number">436</span> INFO [worker1] starting<br><span class="hljs-number">2017</span>-03-<span class="hljs-number">20</span> <span class="hljs-number">23</span>:<span class="hljs-number">28</span>:07,<span class="hljs-number">492</span> INFO [worker2] starting<br><span class="hljs-number">2017</span>-03-<span class="hljs-number">20</span> <span class="hljs-number">23</span>:<span class="hljs-number">28</span>:07,<span class="hljs-number">492</span> INFO [MainThread] stopping  <span class="hljs-comment"># 主线程执行完成</span><br><span class="hljs-number">2017</span>-03-<span class="hljs-number">20</span> <span class="hljs-number">23</span>:<span class="hljs-number">28</span>:08,<span class="hljs-number">439</span> INFO [worker1] stopping  <span class="hljs-comment"># 主线程执行完成之后会等Non-Daemon线程执行完成，但是并不会等Daemon线程执行完成，即Daemon线程会随着主线程执行完成而释放</span><br></code></pre></td></tr></table></figure><h3 id="Thread-join"><a href="#Thread-join" class="headerlink" title="Thread.join()"></a>Thread.join()</h3><p>如果想等Daemon线程执行完成之后主线程再退出，可以使用线程对象的<code>join()</code>方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> threading<br><br>logging.basicConfig(level=logging.DEBUG, <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s %(levelname)s [%(threadName)s] %(message)s&#x27;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>():<br>    logging.info(<span class="hljs-string">&#x27;starting&#x27;</span>)<br>    time.sleep(<span class="hljs-number">2</span>)<br>    logging.info(<span class="hljs-string">&#x27;stopping&#x27;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    logging.info(<span class="hljs-string">&#x27;starting&#x27;</span>)<br>    t1 = threading.Thread(target=worker, name=<span class="hljs-string">&#x27;worker1&#x27;</span>, daemon=<span class="hljs-literal">False</span>)<br>    t1.start()<br>    time.sleep(<span class="hljs-number">1</span>)<br>    t2 = threading.Thread(target=worker, name=<span class="hljs-string">&#x27;worker2&#x27;</span>, daemon=<span class="hljs-literal">True</span>)<br>    t2.start()<br>    logging.info(<span class="hljs-string">&#x27;stopping&#x27;</span>)<br>    t1.join()<br>    t2.join()<br><br><span class="hljs-comment"># 输出</span><br><span class="hljs-number">2017</span>-03-<span class="hljs-number">20</span> <span class="hljs-number">23</span>:<span class="hljs-number">41</span>:07,<span class="hljs-number">217</span> INFO [MainThread] starting<br><span class="hljs-number">2017</span>-03-<span class="hljs-number">20</span> <span class="hljs-number">23</span>:<span class="hljs-number">41</span>:07,<span class="hljs-number">243</span> INFO [worker1] starting<br><span class="hljs-number">2017</span>-03-<span class="hljs-number">20</span> <span class="hljs-number">23</span>:<span class="hljs-number">41</span>:08,<span class="hljs-number">245</span> INFO [worker2] starting<br><span class="hljs-number">2017</span>-03-<span class="hljs-number">20</span> <span class="hljs-number">23</span>:<span class="hljs-number">41</span>:08,<span class="hljs-number">246</span> INFO [MainThread] stopping<br><span class="hljs-number">2017</span>-03-<span class="hljs-number">20</span> <span class="hljs-number">23</span>:<span class="hljs-number">41</span>:09,<span class="hljs-number">243</span> INFO [worker1] stopping<br><span class="hljs-number">2017</span>-03-<span class="hljs-number">20</span> <span class="hljs-number">23</span>:<span class="hljs-number">41</span>:<span class="hljs-number">10</span>,<span class="hljs-number">248</span> INFO [worker2] stopping<br></code></pre></td></tr></table></figure><p>使用join函数只有主线程就需要等待Daemon线程执行完成在推出。</p><p>join函数的原型：<code>join(self, timeout=None)</code></p><p>join方法会阻塞直到线程退出或者超时, timeout 是可选的，如果不设置timeout， 会一直等待线程退出。如果设置了timeout，会在超时之后退出或者线程执行完成退出。</p><p>因为join函数总是返回None，因此在超时时间到达之后如果要知道线程是否还是存活的，可以调用is_alive()方法判断线程是否存活。</p><h2 id="threading常用方法"><a href="#threading常用方法" class="headerlink" title="threading常用方法"></a>threading常用方法</h2><h3 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate()"></a>enumerate()</h3><p>列出当前所有的<strong>存活</strong>的线程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>threading.<span class="hljs-built_in">enumerate</span>()<br>[&lt;_MainThread(MainThread, started <span class="hljs-number">140209670301504</span>)&gt;, &lt;Thread(worker1, started <span class="hljs-number">140209545410304</span>)&gt;, &lt;Thread(worker2, started daemon <span class="hljs-number">140209537017600</span>)&gt;]<br></code></pre></td></tr></table></figure><h3 id="local"><a href="#local" class="headerlink" title="local()"></a>local()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">import</span> threading<br><br>logging.basicConfig(level=logging.DEBUG, <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s %(levelname)s [%(threadName)s] %(message)s&#x27;</span>)<br><br>ctx = threading.local()<br>ctx.data = <span class="hljs-number">5</span><br>data = <span class="hljs-string">&#x27;a&#x27;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>():<br>    logging.info(data)<br>    logging.info(ctx.data)<br><br>worker()<br>threading.Thread(target=worker).start()<br><br><span class="hljs-comment"># 输出</span><br><span class="hljs-number">2017</span>-03-<span class="hljs-number">21</span> <span class="hljs-number">00</span>:02:08,<span class="hljs-number">102</span> INFO [MainThread] a<br><span class="hljs-number">2017</span>-03-<span class="hljs-number">21</span> <span class="hljs-number">00</span>:02:08,<span class="hljs-number">113</span> INFO [MainThread] <span class="hljs-number">5</span><br><span class="hljs-number">2017</span>-03-<span class="hljs-number">21</span> <span class="hljs-number">00</span>:02:08,<span class="hljs-number">119</span> INFO [Thread-<span class="hljs-number">34</span>] a<br>Exception <span class="hljs-keyword">in</span> thread Thread-<span class="hljs-number">34</span>:<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;/home/clg/.pyenv/versions/3.5.2/lib/python3.5/threading.py&quot;</span>, line <span class="hljs-number">914</span>, <span class="hljs-keyword">in</span> _bootstrap_inner<br>    self.run()<br>  File <span class="hljs-string">&quot;/home/clg/.pyenv/versions/3.5.2/lib/python3.5/threading.py&quot;</span>, line <span class="hljs-number">862</span>, <span class="hljs-keyword">in</span> run<br>    self._target(*self._args, **self._kwargs)<br>  File <span class="hljs-string">&quot;&lt;ipython-input-28-5395bd925d87&gt;&quot;</span>, line <span class="hljs-number">7</span>, <span class="hljs-keyword">in</span> worker<br>    logging.info(ctx.data)<br>AttributeError: <span class="hljs-string">&#x27;_thread._local&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;data&#x27;</span><br></code></pre></td></tr></table></figure><p>线程共享内存、状态和资源。但是thread模块的local类的对象的属性， 只在当前线程可见。</p><h2 id="Thread类的派生"><a href="#Thread类的派生" class="headerlink" title="Thread类的派生"></a>Thread类的派生</h2><p>Python中可以通过继承 <code>Thread</code> 类并重写 <code>run</code> 方法来编写多线程的逻辑，此时逻辑函数就是run。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">mythread</span>(threading.Thread):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;mythread run&#x27;</span>)<br><br>t = mythread()<br>t.run()  <span class="hljs-comment"># 输出mythread run</span><br>t.start()  <span class="hljs-comment"># 输出mythread run</span><br></code></pre></td></tr></table></figure><p>通过继承方式派生而来的子类对象可以同时执行start方法和run方法，结果是一样的，都是执行子类的run方法。但是非继承的方式不能同时使用start方法和run方法，会报错。</p><p><strong>派生时逻辑函数的参数传递</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">mythread</span>(threading.Thread):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, *args, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>().__init__()  <span class="hljs-comment"># 需要调用父类的初始化方法初始化</span><br>        self.args = args<br>        self.kwargs = kwargs<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;mythread run&#x27;</span>, self.args, self.kwargs)<br><br>t = mythread(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, a=<span class="hljs-string">&#x27;b&#x27;</span>)<br>t.start()  <span class="hljs-comment"># 输出mythread run (1, 2, 3) &#123;&#x27;a&#x27;: &#x27;b&#x27;&#125;</span><br></code></pre></td></tr></table></figure><h2 id="Timer类"><a href="#Timer类" class="headerlink" title="Timer类"></a>Timer类</h2><p>Timer类：Thread类的派生类，也在threading模块中。意为定时器，用作线程的延迟执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">help</span>(threading.Timer)<br></code></pre></td></tr></table></figure><p>Timer类的初始化方法：<code>__init__(self, interval, function, args=None, kwargs=None)</code></p><ul><li>interval：时间间隔，即几秒之后开始执行function</li><li>function：线程执行的逻辑函数</li><li>args：位置参数</li><li>kwargs：关键字参数</li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> logging<br><br>logging.basicConfig(level=logging.DEBUG, <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s %(levelname)s [%(threadName)s] %(message)s&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>():<br>    logging.info(<span class="hljs-string">&#x27;worker running&#x27;</span>)<br><br>t1 = threading.Timer(interval=<span class="hljs-number">3</span>, function=worker)<br>t2 = threading.Timer(interval=<span class="hljs-number">3</span>, function=worker)<br>t1.setName(<span class="hljs-string">&#x27;t1&#x27;</span>)<br>t2.setName(<span class="hljs-string">&#x27;t2&#x27;</span>)<br>logging.info(<span class="hljs-string">&#x27;start&#x27;</span>)<br>t1.start()<br>t2.start()<br>time.sleep(<span class="hljs-number">2</span>)<br>logging.info(<span class="hljs-string">&#x27;canceling &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(t1.name))<br>t1.cancel()  <span class="hljs-comment"># 2s之后仍然可以取消t1</span><br>logging.info(<span class="hljs-string">&#x27;end&#x27;</span>)<br><br><span class="hljs-comment"># 输出</span><br><span class="hljs-number">2017</span>-03-<span class="hljs-number">21</span> <span class="hljs-number">19</span>:<span class="hljs-number">28</span>:<span class="hljs-number">52</span>,<span class="hljs-number">801</span> INFO [MainThread] start<br><span class="hljs-number">2017</span>-03-<span class="hljs-number">21</span> <span class="hljs-number">19</span>:<span class="hljs-number">28</span>:<span class="hljs-number">54</span>,<span class="hljs-number">811</span> INFO [MainThread] canceling t1<br><span class="hljs-number">2017</span>-03-<span class="hljs-number">21</span> <span class="hljs-number">19</span>:<span class="hljs-number">28</span>:<span class="hljs-number">54</span>,<span class="hljs-number">819</span> INFO [MainThread] end<br><span class="hljs-number">2017</span>-03-<span class="hljs-number">21</span> <span class="hljs-number">19</span>:<span class="hljs-number">28</span>:<span class="hljs-number">55</span>,<span class="hljs-number">808</span> INFO [t2] worker running<br></code></pre></td></tr></table></figure><p>**Timer.cancel()**：取消仍然存活的定时器，如果定时器已经开始执行function，则无法取消。</p><p>**Timer.setDaemon(True)**：设置定时器为守护线程</p><h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>当使用多个线程来访问同一个数据时，会经常出现资源争用等线程安全问题(比如多个线程都在操作同一数据导致数据不一致)，这时候我们就可以使用一些同步技术来解决这类问题。比如Event，Lock，Condition，Barrier，Semaphore等等。</p><h2 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">help</span>(threading.Event)<br></code></pre></td></tr></table></figure><p>Event对象内置一个标志，这个标志可以由**set()<strong>方法和</strong>clear()<strong>方法设定。线程可以使用</strong>wait()**方法进行阻塞等待，知道Event对象内置标志被set。</p><ol><li>**clear(self)**：设置内置标志为False</li><li>**set(self)**：设置内置标志为True</li><li>**wait(self, timeout&#x3D;None)**：开始阻塞，直到内置标志被设置为True（即wait会阻塞线程直到set方法被调用或者超时）</li><li>**is_set(self)**：当且仅当内置标志为True的时候返回True</li></ol><p>代码</p><p>以下代码实现的逻辑是：一个boss和五个睡觉工人，只要有一个工人完成了睡觉任务，那么就唤醒boss和其他工人。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">import</span> random<br><br>logging.basicConfig(level=logging.DEBUG, <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s %(levelname)s [%(threadName)s] %(message)s&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>(<span class="hljs-params">event: threading.Event</span>):<br>    s = random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)<br>    event.wait(s)  <span class="hljs-comment"># wait方法而不使用sleep方法，可以让其他工人收到通知后不再等待</span><br>    logging.info(<span class="hljs-string">&#x27;sleep &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(s))<br>    event.<span class="hljs-built_in">set</span>()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">boss</span>(<span class="hljs-params">event:threading.Event</span>):<br>    start = datetime.datetime.now()<br>    event.wait()<br>    end = datetime.datetime.now()<br>    logging.info(<span class="hljs-string">&#x27;that boss exit takes &#123;&#125;s&#x27;</span>.<span class="hljs-built_in">format</span>(end - start))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>():<br>    event = threading.Event()<br>    b = threading.Thread(target=boss, args=(event, ), name=<span class="hljs-string">&#x27;boss&#x27;</span>)<br>    b.start()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        t = threading.Thread(target=worker, args=(event, ), name=<span class="hljs-string">&#x27;worker-&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i))<br>        t.start()<br></code></pre></td></tr></table></figure><p>执行start()方法，测试结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>start()<br><br><span class="hljs-number">2017</span>-03-<span class="hljs-number">21</span> <span class="hljs-number">21</span>:<span class="hljs-number">20</span>:<span class="hljs-number">17</span>,<span class="hljs-number">195</span> INFO [worker-<span class="hljs-number">2</span>] sleep <span class="hljs-number">1</span><br><span class="hljs-number">2017</span>-03-<span class="hljs-number">21</span> <span class="hljs-number">21</span>:<span class="hljs-number">20</span>:<span class="hljs-number">17</span>,<span class="hljs-number">198</span> INFO [boss] that boss exit takes <span class="hljs-number">0</span>:<span class="hljs-number">00</span>:<span class="hljs-number">01.004954</span>s<br><span class="hljs-number">2017</span>-03-<span class="hljs-number">21</span> <span class="hljs-number">21</span>:<span class="hljs-number">20</span>:<span class="hljs-number">17</span>,<span class="hljs-number">199</span> INFO [worker-<span class="hljs-number">0</span>] sleep <span class="hljs-number">2</span><br><span class="hljs-number">2017</span>-03-<span class="hljs-number">21</span> <span class="hljs-number">21</span>:<span class="hljs-number">20</span>:<span class="hljs-number">17</span>,<span class="hljs-number">199</span> INFO [worker-<span class="hljs-number">1</span>] sleep <span class="hljs-number">3</span><br><span class="hljs-number">2017</span>-03-<span class="hljs-number">21</span> <span class="hljs-number">21</span>:<span class="hljs-number">20</span>:<span class="hljs-number">17</span>,<span class="hljs-number">199</span> INFO [worker-<span class="hljs-number">3</span>] sleep <span class="hljs-number">2</span><br><span class="hljs-number">2017</span>-03-<span class="hljs-number">21</span> <span class="hljs-number">21</span>:<span class="hljs-number">20</span>:<span class="hljs-number">17</span>,<span class="hljs-number">198</span> INFO [worker-<span class="hljs-number">4</span>] sleep <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>可以看到：worker-2退出之后，boss和另外四个worker也瞬间就退出了。所以event对象的内置状态被set之后，相关线程就不再wait了。</p><ul><li>event：在线程之间发送信号，通常用于某个线程需要等待其他线程处理完成某些动作之后才能启动</li></ul><p><strong>wait()方法的timeout参数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>(<span class="hljs-params">event: threading.Event</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> event.wait(<span class="hljs-number">3</span>):<br>        logging.info(<span class="hljs-string">&#x27;run run run&#x27;</span>)<br><br>event = threading.Event()<br>threading.Thread(target=worker, args=(event, )).start()<br><br><span class="hljs-comment"># 输出</span><br><span class="hljs-number">2017</span>-03-<span class="hljs-number">21</span> <span class="hljs-number">21</span>:<span class="hljs-number">32</span>:<span class="hljs-number">47</span>,<span class="hljs-number">275</span> INFO [Thread-<span class="hljs-number">8</span>] run run run<br><span class="hljs-number">2017</span>-03-<span class="hljs-number">21</span> <span class="hljs-number">21</span>:<span class="hljs-number">32</span>:<span class="hljs-number">50</span>,<span class="hljs-number">277</span> INFO [Thread-<span class="hljs-number">8</span>] run run run<br><span class="hljs-number">2017</span>-03-<span class="hljs-number">21</span> <span class="hljs-number">21</span>:<span class="hljs-number">32</span>:<span class="hljs-number">53</span>,<span class="hljs-number">281</span> INFO [Thread-<span class="hljs-number">8</span>] run run run<br><span class="hljs-number">2017</span>-03-<span class="hljs-number">21</span> <span class="hljs-number">21</span>:<span class="hljs-number">32</span>:<span class="hljs-number">56</span>,<span class="hljs-number">284</span> INFO [Thread-<span class="hljs-number">8</span>] run run run<br>...<br></code></pre></td></tr></table></figure><p>程序每隔3s就会输出一次结果，直到执行set()方法才会停止。因此我们可以写一个定时器（类似于Thread类的派生类Timer）。</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, interval, function, *args, **kwargs</span>):<br>        self.interval = interval<br>        self.function = function<br>        self.args = args<br>        self.kwargs = kwargs<br>        self.event = threading.Event()<br>        self.thread = threading.Thread(target=self.__target(), args=args, kwargs=kwargs)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__target</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.event.wait(self.interval):<br>            <span class="hljs-keyword">return</span> self.function<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):<br>        self.thread.start()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cancel</span>(<span class="hljs-params">self</span>):<br>        self.event.<span class="hljs-built_in">set</span>()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>(<span class="hljs-params">act</span>):<br>    logging.info(<span class="hljs-string">&#x27;run-&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(act))<br><br>t = Timer(<span class="hljs-number">5</span>, worker, <span class="hljs-string">&#x27;hahaha&#x27;</span>)<br>t.start()  <span class="hljs-comment"># 输出2017-03-21 22:14:59,645 INFO [Thread-20] run-hahaha</span><br></code></pre></td></tr></table></figure><p>延迟5s之后执行了逻辑函数，也可以使用cancel函数取消。（<strong>要注意参数的传递，此处Timer初始化不能使用关键字参数</strong>）</p><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>event是用来同步线程之间的操作的，但是如果要控制共享资源的访问那就需要用到锁机制了，在Python标准库中的实现就是内置的lock类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">help</span>(threading.Lock)<br></code></pre></td></tr></table></figure><p>**threading.Lock()**函数会创建一个lock类的对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">help</span>(threading.Lock())<br></code></pre></td></tr></table></figure><p>锁对象是一个同步原语（synchronization primitive），lock对象主要有以下三个方法：</p><ol><li>acquire()： acquire(blocking&#x3D;True, timeout&#x3D;-1) -&gt; bool 获得锁（即锁定锁）。成功获得锁返回True，没有获得锁则返回False。</li><li>release()： release() 释放锁</li><li>locked()： locked() -&gt; bool 检查锁是否被锁住</li></ol><p><strong>代码</strong></p><p>以下代码实现了在多个进程同时对资源进行访问时，进行加锁和解锁的操作，保证加减操作和赋值操作组合之后的原子性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span>:  <span class="hljs-comment"># 计时器有加减方法，都会修改value值，因此都需要加锁处理</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, start=<span class="hljs-number">0</span></span>):<br>        self.value = start<br>        self.lock = threading.Lock()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inc</span>(<span class="hljs-params">self</span>):<br>        self.lock.acquire()<br>        <span class="hljs-keyword">try</span>:<br>            self.value += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">finally</span>:<br>            self.lock.release()  <span class="hljs-comment"># 需要用finally语句保证锁一定会被释放，否则资源永远不可访问</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dec</span>(<span class="hljs-params">self</span>):<br>        self.lock.acquire()<br>        <span class="hljs-keyword">try</span>:<br>            self.value -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">finally</span>:<br>            self.lock.release()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">inc_worker</span>(<span class="hljs-params">c: Counter</span>):<br>    pause = random.random()<br>    logging.info(<span class="hljs-string">&#x27;sleeping-&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(pause))<br>    time.sleep(pause)<br>    c.inc()<br>    logging.info(<span class="hljs-string">&#x27;cur_value:&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(c.value))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dec_worker</span>(<span class="hljs-params">c: Counter</span>):<br>    pause = random.random()<br>    logging.info(<span class="hljs-string">&#x27;sleeping-&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(pause))<br>    time.sleep(pause)<br>    c.dec()<br>    logging.info(<span class="hljs-string">&#x27;cur_value:&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(c.value))<br><br>c = Counter()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br>    threading.Thread(target=inc_worker, args=(c, ), name=<span class="hljs-string">&#x27;inc_worker-&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i)).start()<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>    threading.Thread(target=dec_worker, args=(c, ), name=<span class="hljs-string">&#x27;dec_worker-&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i)).start()<br></code></pre></td></tr></table></figure><p>测试输出</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs subunit">2017<span class="hljs-string">-03</span><span class="hljs-string">-21</span> 23:17:44,761 INFO [inc_worker<span class="hljs-string">-0</span>] sleeping<span class="hljs-string">-0</span>.6542416949220327<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-21</span> 23:17:44,766 INFO [inc_worker<span class="hljs-string">-1</span>] sleeping<span class="hljs-string">-0</span>.48615543229897873<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-21</span> 23:17:44,771 INFO [dec_worker<span class="hljs-string">-0</span>] sleeping<span class="hljs-string">-0</span>.12355589507242459<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-21</span> 23:17:44,776 INFO [dec_worker<span class="hljs-string">-1</span>] sleeping<span class="hljs-string">-0</span>.5276710391905681<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-21</span> 23:17:44,784 INFO [dec_worker<span class="hljs-string">-2</span>] sleeping<span class="hljs-string">-0</span>.5546251407611247<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-21</span> 23:17:44,900 INFO [dec_worker<span class="hljs-string">-0</span>] cur_value:<span class="hljs-string">-1</span><br>2017<span class="hljs-string">-03</span><span class="hljs-string">-21</span> 23:17:45,258 INFO [inc_worker<span class="hljs-string">-1</span>] cur_value:0<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-21</span> 23:17:45,312 INFO [dec_worker<span class="hljs-string">-1</span>] cur_value:<span class="hljs-string">-1</span><br>2017<span class="hljs-string">-03</span><span class="hljs-string">-21</span> 23:17:45,351 INFO [dec_worker<span class="hljs-string">-2</span>] cur_value:<span class="hljs-string">-2</span><br>2017<span class="hljs-string">-03</span><span class="hljs-string">-21</span> 23:17:45,421 INFO [inc_worker<span class="hljs-string">-0</span>] cur_value:<span class="hljs-string">-1</span><br></code></pre></td></tr></table></figure><p>可见，各项操作之间保持相互原子性，没有出现干扰。</p><p>因为lock类实现了<code>__enter__</code>和<code>__exit__</code>两个魔术方法，因此支持上下文管理器，可以修改以上Counter类的实现方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, start=<span class="hljs-number">0</span></span>):<br>        self.value = start<br>        self.lock = threading.Lock()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inc</span>(<span class="hljs-params">self</span>):<br>        self.lock.acquire()<br>        <span class="hljs-keyword">with</span> self.lock:<br>            self.value += <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dec</span>(<span class="hljs-params">self</span>):<br>        self.lock.acquire()<br>        <span class="hljs-keyword">with</span> self.lock:<br>            self.value -= <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>即使用上下文管理器来代替<code>try...finally...</code>语句，测试输出应该以以上结果一致。</p><p><strong>acquire方法的blocking参数</strong></p><p>当blocking&#x3D;True时，A线程中执行了lock.acquire()方法之后并且没有执行到lock.release()方法，如果在B线程中再次执行lock.acquire()方法，则B线程阻塞。</p><ul><li>正如以上代码实现，当有n个线程需要修改一个共享资源的时候，其他线程在获取锁之前都处于阻塞状态。（python的阻塞都会让出cpu的时间片，因此不是忙等待）</li></ul><p>当blocking&#x3D;Fasle时，A线程中执行了lock.acquire()方法之后并且没有执行到lock.release()方法，如果在B线程中再次执行lock.acquire()方法，则B线程不会阻塞，并且acquire函数返回False。</p><p><strong>acquire方法的timeout参数</strong></p><p>当blocking&#x3D;True并且timeout&gt;0时，acquire会一直阻塞到超时或者锁被释放。</p><p><strong>acquire(0)的参数传递</strong></p><p>模拟acquire方法的默认参数，编写一下函数进行模拟参数传递的过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">print1</span>(<span class="hljs-params">blocking=<span class="hljs-literal">True</span>, timeout=-<span class="hljs-number">1</span></span>):<br>    <span class="hljs-built_in">print</span>(blocking, timeout)<br><br>print1(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 输出0 -1</span><br>print1(<span class="hljs-number">10</span>)  <span class="hljs-comment"># 输出10 -1</span><br></code></pre></td></tr></table></figure><p>可见第一个位置参数，替代了blocking。也就是说lock.acquire(0)等效于lock.acquire(blocking&#x3D;False)</p><h2 id="RLock"><a href="#RLock" class="headerlink" title="RLock"></a>RLock</h2><p>正常的lock对象是不能多次调用<code>acquire</code>的，但是可重用锁<code>RLock</code>可以多次调用 <code>acquire</code> 而不阻塞，而且 <code>release</code> 时也要执行和 <code>acquire</code> 一样的次数。</p><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>除了Event对象之外，线程同步还可以使用条件同步机制Condition。一类线程等待特定条件，而另一类线程发出特定条件满足的信号。</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">help</span>(threading.Condition)</span><br></code></pre></td></tr></table></figure><p>在Condition的帮助中有以下几个方法：</p><ul><li>初始化方法：**init(self, lock&#x3D;None)**。如果给定了lock参数，那么必须是Lock或者Rlock对象，并且被当做底层锁来使用。如果没有指定，那么会创建一个RLock对象的锁，也被当做底层锁来使用。</li><li>实现了<code>__enter__</code>和<code>__exit__</code>方法，支持上下文管理器。</li><li>notify(self, n&#x3D;1)：唤醒一个或多个在当前Condition上等待的其他线程，如果此方法的调用线程没有获得锁，那么在调用的时候就会报错RuntimeError</li><li>notify_all(self)：唤醒所有线程</li><li>wait(self, timeout&#x3D;None)：一直等待着知道被notifyed或者发生超时</li></ul><p><strong>实例代码</strong></p><p>以下代码实现的是：有一个生产者线程，会生产若干次，每次生产结束后需要通知所有的消费者线程来消费，因此下面代码使用的是notify_all方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">import</span> random<br>logging.basicConfig(level=logging.DEBUG, <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s %(levelname)s [%(threadName)s] %(message)s&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer_Consumer_Model</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.data = <span class="hljs-literal">None</span><br>        self.event = threading.Event()  <span class="hljs-comment"># 用来控制消费者退出</span><br>        self.condition = threading.Condition()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">Consumer</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> self.event.is_set():<br>            <span class="hljs-keyword">with</span> self.condition:<br>                self.condition.wait()  <span class="hljs-comment"># 一直等待直到收到生产者通知notify_all</span><br>                logging.info(self.data)  <span class="hljs-comment"># 收到通知之后，开始执行消费者的业务逻辑部分</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">Producer</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):  <span class="hljs-comment"># 每个生产者生产4次</span><br>            data = random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>)<br>            logging.info(data)<br>            <span class="hljs-keyword">with</span> self.condition:<br>                self.data = data  <span class="hljs-comment"># 写入成功就表示生产成功，因此需要在此加锁并且能够通知消费者线程去消费，因此选择使用condition来处理</span><br>                self.condition.notify_all()  <span class="hljs-comment"># 生产成功之后通知所有的消费者去消费</span><br>            self.event.wait(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 没生产一次等待1s</span><br>        self.event.<span class="hljs-built_in">set</span>()  <span class="hljs-comment"># 所有的生产完成之后通知消费者退出</span><br><br>m = Producer_Consumer_Model()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>    threading.Thread(target=m.Consumer, name=<span class="hljs-string">&#x27;Consumer-&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i)).start()<br><br>p = threading.Thread(target=m.Producer, name=<span class="hljs-string">&#x27;Producer&#x27;</span>)<br>p.start()<br></code></pre></td></tr></table></figure><p>测试结果（一个生产者，三个消费者）</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs subunit">2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 22:07:42,875 INFO [Producer] 16<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 22:07:42,883 INFO [Consumer<span class="hljs-string">-0</span>] 16<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 22:07:42,890 INFO [Consumer<span class="hljs-string">-2</span>] 16<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 22:07:42,894 INFO [Consumer<span class="hljs-string">-1</span>] 16<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 22:07:43,884 INFO [Producer] 76<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 22:07:43,888 INFO [Consumer<span class="hljs-string">-0</span>] 76<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 22:07:43,895 INFO [Consumer<span class="hljs-string">-2</span>] 76<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 22:07:43,898 INFO [Consumer<span class="hljs-string">-1</span>] 76<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 22:07:44,889 INFO [Producer] 31<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 22:07:44,891 INFO [Consumer<span class="hljs-string">-0</span>] 31<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 22:07:44,911 INFO [Consumer<span class="hljs-string">-2</span>] 31<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 22:07:44,913 INFO [Consumer<span class="hljs-string">-1</span>] 31<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 22:07:45,892 INFO [Producer] 17<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 22:07:45,894 INFO [Consumer<span class="hljs-string">-0</span>] 17<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 22:07:45,907 INFO [Consumer<span class="hljs-string">-2</span>] 17<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 22:07:45,910 INFO [Consumer<span class="hljs-string">-1</span>] 17<br></code></pre></td></tr></table></figure><p>可见，生产者每生产一次，所有的消费者就会去消费。如果想控制每次生产之后通知几个消费者来消费，那么就可以使用notify方法，指定消费者线程个数。</p><p>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">import</span> random<br>logging.basicConfig(level=logging.DEBUG, <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s %(levelname)s [%(threadName)s] %(message)s&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer_Consumer_Model</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.data = <span class="hljs-literal">None</span><br>        self.event = threading.Event()  <span class="hljs-comment"># 用来控制消费者退出</span><br>        self.condition = threading.Condition()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">Consumer</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> self.event.is_set():<br>            <span class="hljs-keyword">with</span> self.condition:<br>                self.condition.wait()  <span class="hljs-comment"># 一直等待直到收到生产者通知notify_all</span><br>                logging.info(self.data)  <span class="hljs-comment"># 收到通知之后，开始执行消费者的业务逻辑部分</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">Producer</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):  <span class="hljs-comment"># 每个生产者生产4次</span><br>            data = random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>)<br>            logging.info(data)<br>            <span class="hljs-keyword">with</span> self.condition:<br>                self.data = data  <span class="hljs-comment"># 写入成功就表示生产成功，因此需要在此加锁并且能够通知消费者线程去消费，因此选择使用condition来处理</span><br>                self.condition.notify(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 生产成功之后通知所有的消费者去消费</span><br>            self.event.wait(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 没生产一次等待1s</span><br>        self.event.<span class="hljs-built_in">set</span>()  <span class="hljs-comment"># 所有的生产完成之后通知消费者退出</span><br><br>m = Producer_Consumer_Model()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>    threading.Thread(target=m.Consumer, name=<span class="hljs-string">&#x27;Consumer-&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i)).start()<br><br>p = threading.Thread(target=m.Producer, name=<span class="hljs-string">&#x27;Producer&#x27;</span>)<br>p.start()<br></code></pre></td></tr></table></figure><p>测试结果（一个生产者，三个消费者，每次生产之后只通知一个消费者去消费）</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs subunit">2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 22:24:52,933 INFO [Producer] 11<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 22:24:52,948 INFO [Consumer<span class="hljs-string">-0</span>] 11<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 22:24:53,949 INFO [Producer] 47<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 22:24:53,967 INFO [Consumer<span class="hljs-string">-1</span>] 47<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 22:24:54,967 INFO [Producer] 14<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 22:24:54,983 INFO [Consumer<span class="hljs-string">-2</span>] 14<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 22:24:55,986 INFO [Producer] 54<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 22:24:55,993 INFO [Consumer<span class="hljs-string">-0</span>] 54<br></code></pre></td></tr></table></figure><blockquote><ol><li>Condition 通常用于生产者消费者模式， 生产者生产消息之后， 使用notify 或者 notify_all 通知消费者消费。</li><li>消费者使用wait方法阻塞等待生产者通知</li><li>notify通知指定个wait的线程， notify_all通知所有的wait线程</li><li>无论notify&#x2F;notify_all还是wait 都必须先acqurie， 完成后必须确保release， 通常使用with语法</li></ol></blockquote><h2 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h2><p>Barrier类存在于threading模块中，中文可以翻译成栅栏</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">help</span>(threading.Barrier)<br></code></pre></td></tr></table></figure><p>可以看到Barrier的主要方法和属性：</p><ul><li><code>__init__(self, parties, action=None, timeout=None)</code>：初始化方法，创建一个Barrier<ul><li><code>parties</code>：所有参与的线程的数量</li><li><code>action</code>：所有的线程都wait之后并且在线程释放之前就会执行这个action函数，相当于集结之后要做的事情。</li><li><code>timeout</code>：相当于给需要等待的每个线程的wait方法加上timeout参数，超时则barrier不再生效</li></ul></li><li><code>abort(self)</code>：将Barrier设置成broken状态</li><li><code>reset(self)</code>：将Barrier重置为最初状态</li><li><code>wait(self, timeout=None)</code>：在Barrier前等待，返回在Barrier前等待的下标，从0到parties-1</li><li><code>broken</code>：如果Barrier处于broken状态则返回True</li><li><code>n_waiting</code>：当前已经在Barrier处等待的线程的数量</li><li><code>parties</code>：需要在Barrier处等待的线程的数量</li></ul><p><strong>示例代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> logging<br><br>logging.basicConfig(level=logging.DEBUG, <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s %(levelname)s [%(threadName)s] %(message)s&#x27;</span>)<br><br>barrier = threading.Barrier(parties=<span class="hljs-number">3</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>(<span class="hljs-params">barrier: threading.Barrier</span>):<br>    logging.info(<span class="hljs-string">&#x27;waiting for barrier with &#123;&#125; others&#x27;</span>.<span class="hljs-built_in">format</span>(barrier.n_waiting))<br>    worker_id = barrier.wait()<br>    logging.info(<span class="hljs-string">&#x27;after barrier &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(worker_id))<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>    threading.Thread(target=worker, args=(barrier, ), name=<span class="hljs-string">&#x27;worker-&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i)).start()<br></code></pre></td></tr></table></figure><p>测试结果</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs subunit">2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 23:25:03,992 INFO [worker<span class="hljs-string">-0</span>] waiting for barrier with 0 others<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 23:25:03,995 INFO [worker<span class="hljs-string">-1</span>] waiting for barrier with 1 others<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 23:25:03,998 INFO [worker<span class="hljs-string">-2</span>] waiting for barrier with 2 others<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 23:25:04,001 INFO [worker<span class="hljs-string">-2</span>] after barrier 2<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 23:25:04,001 INFO [worker<span class="hljs-string">-0</span>] after barrier 0<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 23:25:04,001 INFO [worker<span class="hljs-string">-1</span>] after barrier 1<br></code></pre></td></tr></table></figure><p>可见，所有的线程都会一直等待，知道所有的线程都到期了，然后就通过barrier，继续执行后续操作。</p><blockquote><p>Barrier会建立一个控制点，所有参与的线程都会阻塞，直到所有参与的“各方”达到这一点。 它让线程分开启动，然后暂停，直到它们都准备好再继续。因此，这一点可以理解为各个线程的一个集结点。</p></blockquote><p><strong>abort函数的使用</strong></p><p>将Barrier设置成broken状态。所有线程在参与集结过程中，只要执行了barrier.abort方法，那么正在等待的线程都会抛出threading.BrokenBarrierError异常。可以理解为，只要有一个线程确定已经到不了Barrier并且通知了Barrier，那么Barrier就会执行abort方法，通知所有正在wait的线程放弃集结。</p><p><strong>实例代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> logging<br><br>logging.basicConfig(level=logging.DEBUG, <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s %(levelname)s [%(threadName)s] %(message)s&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>(<span class="hljs-params">barrier: threading.Barrier</span>):<br>    logging.info(<span class="hljs-string">&#x27;waiting for barrier with &#123;&#125; others&#x27;</span>.<span class="hljs-built_in">format</span>(barrier.n_waiting))<br>    <span class="hljs-keyword">try</span>:<br>        worker_id = barrier.wait()<br>    <span class="hljs-keyword">except</span> threading.BrokenBarrierError:<br>        logging.info(<span class="hljs-string">&#x27;aborting&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        logging.info(<span class="hljs-string">&#x27;after barrier &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(worker_id))<br><br>barrier = threading.Barrier(<span class="hljs-number">4</span>)  <span class="hljs-comment"># 需要等待4个线程</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>    threading.Thread(target=worker, args=(barrier, ), name=<span class="hljs-string">&#x27;worker-&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i)).start()  <span class="hljs-comment"># 3个线程都开始wait</span><br>barrier.abort()  <span class="hljs-comment"># 还有一个线程没有到wait，此时执行abort方法，则所有正在wait的线程都抛出异常</span><br></code></pre></td></tr></table></figure><p>测试结果</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs subunit">2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 23:47:43,184 INFO [worker<span class="hljs-string">-0</span>] waiting for barrier with 0 others<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 23:47:43,192 INFO [worker<span class="hljs-string">-1</span>] waiting for barrier with 1 others<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 23:47:43,201 INFO [worker<span class="hljs-string">-2</span>] waiting for barrier with 2 others<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 23:47:43,211 INFO [worker<span class="hljs-string">-2</span>] aborting<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 23:47:43,207 INFO [worker<span class="hljs-string">-1</span>] aborting<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-22</span> 23:47:43,207 INFO [worker<span class="hljs-string">-0</span>] aborting<br></code></pre></td></tr></table></figure><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore类存在于threading模块中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">help</span>(threading.Semaphore)<br></code></pre></td></tr></table></figure><p>信号量内部管理者一个计数器，这个计数器的值等于release()方法调用的次数减去acquire()方法调用的次数然后再加上初始值value，value默认为1。</p><p>可以看到Semaphore的主要方法：</p><ul><li><code>__init__(self, value=1)</code>：初始化一个信号量，value为内部计数器赋初值，默认为1</li><li><code>acquire(self, blocking=True, timeout=None)</code>：获取信号量，内部计数器减一</li><li><code>release(self)</code>：释放信号量，内部计数器加一</li></ul><p><strong>示例代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">import</span> random<br>logging.basicConfig(level=logging.DEBUG, <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s %(levelname)s [%(threadName)s] %(message)s&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pool</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, num</span>):<br>        self.num = num<br>        self.conns = [self._make_connect(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num)]  <span class="hljs-comment"># 存放连接</span><br>        self.sem = threading.Semaphore(num)  <span class="hljs-comment"># 信号量内部计数器初始为连接数</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_make_connect</span>(<span class="hljs-params">self, name</span>):  <span class="hljs-comment"># 根据连接名称创建连接</span><br>        conn = <span class="hljs-string">&#x27;connect-&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(name)<br>        <span class="hljs-keyword">return</span> conn<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_connect</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># 从连接池获取连接</span><br>        self.sem.acquire()<br>        <span class="hljs-keyword">return</span> self.conns.pop()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">return_connect</span>(<span class="hljs-params">self, conn</span>):  <span class="hljs-comment"># 将连接conn返还到连接池中</span><br>        self.conns.insert(<span class="hljs-number">0</span>, conn)<br>        self.sem.release()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>(<span class="hljs-params">pool: Pool</span>):<br>    logging.info(<span class="hljs-string">&#x27;starting&#x27;</span>)<br>    conn = pool.get_connect()  <span class="hljs-comment"># 如果获取不到则会阻塞在acquire处</span><br>    logging.info(<span class="hljs-string">&#x27;get connect &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(conn))<br>    t = random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br>    time.sleep(t)<br>    logging.info(<span class="hljs-string">&#x27;takes &#123;&#125;s&#x27;</span>.<span class="hljs-built_in">format</span>(t))<br>    pool.return_connect(conn)<br>    logging.info(<span class="hljs-string">&#x27;return connect &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(conn))<br><br>pool = Pool(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 连接池中有两个连接可以使用</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):  <span class="hljs-comment"># 三个线程使用两个连接开始任务</span><br>    threading.Thread(target=worker, args=(pool, ), name=<span class="hljs-string">&#x27;worker-&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i)).start()<br></code></pre></td></tr></table></figure><p>测试结果</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs subunit">2017<span class="hljs-string">-03</span><span class="hljs-string">-23</span> 00:54:36,056 INFO [worker<span class="hljs-string">-0</span>] starting<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-23</span> 00:54:36,062 INFO [worker<span class="hljs-string">-0</span>] get connect connect<span class="hljs-string">-1</span><br>2017<span class="hljs-string">-03</span><span class="hljs-string">-23</span> 00:54:36,074 INFO [worker<span class="hljs-string">-1</span>] starting<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-23</span> 00:54:36,079 INFO [worker<span class="hljs-string">-1</span>] get connect connect<span class="hljs-string">-0</span><br>2017<span class="hljs-string">-03</span><span class="hljs-string">-23</span> 00:54:36,089 INFO [worker<span class="hljs-string">-2</span>] starting<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-23</span> 00:54:39,074 INFO [worker<span class="hljs-string">-0</span>] takes 3s<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-23</span> 00:54:39,076 INFO [worker<span class="hljs-string">-0</span>] return connect connect<span class="hljs-string">-1</span><br>2017<span class="hljs-string">-03</span><span class="hljs-string">-23</span> 00:54:39,076 INFO [worker<span class="hljs-string">-2</span>] get connect connect<span class="hljs-string">-1</span><br>2017<span class="hljs-string">-03</span><span class="hljs-string">-23</span> 00:54:39,093 INFO [worker<span class="hljs-string">-1</span>] takes 3s<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-23</span> 00:54:39,097 INFO [worker<span class="hljs-string">-1</span>] return connect connect<span class="hljs-string">-0</span><br>2017<span class="hljs-string">-03</span><span class="hljs-string">-23</span> 00:54:40,093 INFO [worker<span class="hljs-string">-2</span>] takes 1s<br>2017<span class="hljs-string">-03</span><span class="hljs-string">-23</span> 00:54:40,107 INFO [worker<span class="hljs-string">-2</span>] return connect connect<span class="hljs-string">-1</span><br></code></pre></td></tr></table></figure><p>这个测试结果显示：三个线程获取连接池中的两个连接，结果出现了一个线程等待其他线程执行完成之后再获取连接的过程。</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>Condition线程同步部分用来传递数据的是一个封装在生产者消费者模型中的元素data（正常使用情况下一般封装的都是一个列表，类似与Barrier部分的连接池中的conns列表）。</p><p>Python的queue模块中提供了同步的、线程安全的队列类，包括三种队列：</p><ul><li>FIFO（先入先出)队列Queue</li><li>LIFO（后入先出）队列LifoQueue</li><li>优先级队列PriorityQueue</li></ul><p>这些队列都实现了锁原语，能够在多线程中直接使用。可以使用队列来实现线程间的同步。因此我们可以使用queue模块来替换掉生产者消费者中的全局元素，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> queue<br><span class="hljs-keyword">import</span> threading<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer_Consumer_Model</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.q = queue.Queue()<br>        self.event = threading.Event()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">Consumer</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> self.event.is_set():<br>            logging.info(self.q.get())<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">Producer</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> self.event.wait(<span class="hljs-number">3</span>):<br>            data = random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>)<br>            logging.info(data)<br>            self.q.put(data)<br><br>m = Producer_Consumer_Model()<br>threading.Thread(target=m.Consumer, name=<span class="hljs-string">&#x27;Consumer&#x27;</span>).start()<br>threading.Thread(target=m.Producer, name=<span class="hljs-string">&#x27;Producer&#x27;</span>).start()<br></code></pre></td></tr></table></figure><p>测试结果</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">2017-03-23</span> <span class="hljs-number">10</span>:<span class="hljs-number">11:22,990</span> INFO [Producer] <span class="hljs-number">26</span><br><span class="hljs-number">2017-03-23</span> <span class="hljs-number">10</span>:<span class="hljs-number">11:22,993</span> INFO [Consumer] <span class="hljs-number">26</span><br><span class="hljs-number">2017-03-23</span> <span class="hljs-number">10</span>:<span class="hljs-number">11:25,993</span> INFO [Producer] <span class="hljs-number">89</span><br><span class="hljs-number">2017-03-23</span> <span class="hljs-number">10</span>:<span class="hljs-number">11:26,003</span> INFO [Consumer] <span class="hljs-number">89</span><br><span class="hljs-number">2017-03-23</span> <span class="hljs-number">10</span>:<span class="hljs-number">11:29,004</span> INFO [Producer] <span class="hljs-number">14</span><br><span class="hljs-number">2017-03-23</span> <span class="hljs-number">10</span>:<span class="hljs-number">11:29,006</span> INFO [Consumer] <span class="hljs-number">14</span><br><span class="hljs-number">2017-03-23</span> <span class="hljs-number">10</span>:<span class="hljs-number">11:32,007</span> INFO [Producer] <span class="hljs-number">17</span><br><span class="hljs-number">2017-03-23</span> <span class="hljs-number">10</span>:<span class="hljs-number">11:32,009</span> INFO [Consumer] <span class="hljs-number">17</span><br></code></pre></td></tr></table></figure><p>每生产一次，消费者就会消费一次。当消费者线程，读取Queue则调用Queue.get()方法，若Queue为空时消费者线程获取不到内容，就会阻塞在这里，直到成功获取内容。</p><p>##线程同步总结</p><ul><li>Event：主要用于线程之间的事件通知</li><li>Lock,Rlock：主要用于保护共享资源</li><li>Condition：主要用于生产者消费者模型，可以理解为Event和Lock的结合体</li><li>Barrier：同步指定个等待的线程</li><li>Semaphore：主要用于保护资源，和Lock的区别在于可以多个线程访问共享资源，而锁一次只能一个线程访问到共享资源，即锁是value&#x3D;1的信号量</li><li>Queue：使用FIFO队列进行同步，适用于生产者消费者模型</li></ul><h1 id="GIL"><a href="#GIL" class="headerlink" title="GIL"></a>GIL</h1><p>GIL（Global Interpreter Lock）：全局解释器锁</p><p>Python代码的执行由Python 主循环来控制，Python 在设计之初就考虑到要在解释器的主循环中，同时只有一个线程在执行，即在任意时刻，只有一个线程在解释器中运行。对Python 主循环的访问由全局解释器锁（GIL）来控制，正是这个锁能保证同一时刻只有一个线程在运行。</p><p>因此Python多线程程序的执行顺序如下：</p><ol><li>设置GIL</li><li>切换到一个线程去运行</li><li>运行</li><li>结束线程</li><li>解锁GIL</li><li>重复以上步骤</li></ol><p>因此，Python的多线程并没有实现并行，只是实现了并发而已。如果要实现真正的并行，那就需要使用Python的多进程模块multiprocessing（multiprocessing模块的宗旨是像管理线程一样来管理进程）。</p><hr><p>参考资料</p><ol><li><a target="_blank" rel="noopener" href="https://pymotw.com/3/threading/index.html">threading — Manage Concurrent Operations Within a Process</a></li><li><a target="_blank" rel="noopener" href="http://yoyzhou.github.io/blog/2013/02/28/python-threads-synchronization-locks/">Python线程同步机制: Locks, RLocks, Semaphores, Conditions, Events和Queues</a></li></ol></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/python/" class="category-chain-item">python</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Python/">#Python</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">#多线程</a> <a href="/tags/threading/">#threading</a></div></div><div class="license-box my-3"><div class="license-title"><div>Python多线程</div><div>https://suncle.me/posts/4097981062.html</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Suncle Chen</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2017年3月23日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/posts/3541559492.html" title="Python网络编程"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Python网络编程</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/posts/1516127351.html" title="Python描述器"><span class="hidden-mobile">Python描述器</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><script type="text/javascript">Fluid.utils.loadComments("#comments",(function(){var t=document.documentElement.getAttribute("data-user-color-scheme");t="dark"===t?"github-dark":"github-light",window.UtterancesThemeLight="github-light",window.UtterancesThemeDark="github-dark";var e=document.createElement("script");e.setAttribute("src","https://utteranc.es/client.js"),e.setAttribute("repo","suncle1993/suncle1993.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("label","utterances"),e.setAttribute("theme",t),e.setAttribute("crossorigin","anonymous"),document.getElementById("comments").appendChild(e)}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var o=jQuery("#board-ctn").offset().top;window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-o}),t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),n=[];for(var i of o)n.push(".markdown-body > "+i.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>